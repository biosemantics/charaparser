//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.04.11 at 02:48:30 PM MST 
//


package semanticMarkup.io.input.lib.taxonx;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;


/**
 * A concrete digir:listType specifying all elements available for multiCOP operations.
 * 
 * <p>Java class for list complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="list">
 *   &lt;complexContent>
 *     &lt;extension base="{http://digir.net/schema/protocol/2003/1.0}listType">
 *       &lt;sequence>
 *         &lt;choice>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}DateLastModified" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}BasisOfRecord" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}InstitutionCode" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}CollectionCode" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}CatalogNumberText" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}CatalogNumberNumeric" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Collector" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}CollectorNumber" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}FieldNumber" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}YearCollected" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MonthCollected" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}DayCollected" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}TimeCollected" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}VerbatimCollectingDate" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}FieldNotes" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}JulianDay" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}HigherGeography" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}ContinentOcean" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}IslandGroup" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Island" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Country" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}StateProvince" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}County" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Locality" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}DecimalLatitude" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}DecimalLongitude" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}HorizontalDatum" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}OriginalCoordinateSystem" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}VerbatimLatitude" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}VerbatimLongitude" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}GeorefMethod" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}CoordinateUncertaintyInMeters" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}LatLongComments" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}BoundingBox" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MinimumElevationInMeters" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MaximumElevationInMeters" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}VerbatimElevation" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MinimumDepthInMeters" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MaximumDepthInMeters" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}VerbatimDepth" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}ScientificName" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}HigherTaxon" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Kingdom" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Phylum" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Class" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Order" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Family" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Genus" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Species" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Subspecies" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}ScientificNameAuthor" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}IdentificationModifier" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}IdentifiedBy" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}YearIdentified" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}MonthIdentified" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}DayIdentified" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}TypeStatus" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Sex" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Preparations" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Tissues" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}IndividualCount" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}AgeClass" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}GenBankNum" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}OtherCatalogNumbers" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}RelatedCatalogedItems" maxOccurs="unbounded"/>
 *           &lt;element ref="{http://digir.net/schema/conceptual/darwin/2003/1.0}Remarks" maxOccurs="unbounded"/>
 *         &lt;/choice>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "list", namespace = "http://digir.net/schema/conceptual/darwin/2003/1.0", propOrder = {
    "dateLastModified",
    "basisOfRecord",
    "institutionCode",
    "collectionCode",
    "catalogNumberText",
    "catalogNumberNumeric",
    "collector",
    "collectorNumber",
    "fieldNumber",
    "yearCollected",
    "monthCollected",
    "dayCollected",
    "timeCollected",
    "verbatimCollectingDate",
    "fieldNotes",
    "julianDay",
    "higherGeography",
    "continentOcean",
    "islandGroup",
    "island",
    "country",
    "stateProvince",
    "county",
    "locality",
    "decimalLatitude",
    "decimalLongitude",
    "horizontalDatum",
    "originalCoordinateSystem",
    "verbatimLatitude",
    "verbatimLongitude",
    "georefMethod",
    "coordinateUncertaintyInMeters",
    "latLongComments",
    "boundingBox",
    "minimumElevationInMeters",
    "maximumElevationInMeters",
    "verbatimElevation",
    "minimumDepthInMeters",
    "maximumDepthInMeters",
    "verbatimDepth",
    "scientificName",
    "higherTaxon",
    "kingdom",
    "phylum",
    "clazz",
    "order",
    "family",
    "genus",
    "species",
    "subspecies",
    "scientificNameAuthor",
    "identificationModifier",
    "identifiedBy",
    "yearIdentified",
    "monthIdentified",
    "dayIdentified",
    "typeStatus",
    "sex",
    "preparations",
    "tissues",
    "individualCount",
    "ageClass",
    "genBankNum",
    "otherCatalogNumbers",
    "relatedCatalogedItems",
    "remarks"
})
public class List
    extends ListType
{

    @XmlElement(name = "DateLastModified", nillable = true)
    @XmlSchemaType(name = "dateTime")
    protected java.util.List<XMLGregorianCalendar> dateLastModified;
    @XmlElement(name = "BasisOfRecord", nillable = true)
    protected java.util.List<String> basisOfRecord;
    @XmlElement(name = "InstitutionCode", nillable = true)
    protected java.util.List<String> institutionCode;
    @XmlElement(name = "CollectionCode", nillable = true)
    protected java.util.List<String> collectionCode;
    @XmlElement(name = "CatalogNumberText", nillable = true)
    protected java.util.List<String> catalogNumberText;
    @XmlElement(name = "CatalogNumberNumeric", nillable = true)
    @XmlSchemaType(name = "nonNegativeInteger")
    protected java.util.List<BigInteger> catalogNumberNumeric;
    @XmlElement(name = "Collector", nillable = true)
    protected java.util.List<String> collector;
    @XmlElement(name = "CollectorNumber", nillable = true)
    protected java.util.List<String> collectorNumber;
    @XmlElement(name = "FieldNumber", nillable = true)
    protected java.util.List<String> fieldNumber;
    @XmlElement(name = "YearCollected", nillable = true)
    @XmlSchemaType(name = "gYear")
    protected java.util.List<XMLGregorianCalendar> yearCollected;
    @XmlElement(name = "MonthCollected", nillable = true)
    protected java.util.List<Integer> monthCollected;
    @XmlElement(name = "DayCollected", nillable = true)
    protected java.util.List<Integer> dayCollected;
    @XmlElement(name = "TimeCollected", nillable = true)
    protected java.util.List<BigDecimal> timeCollected;
    @XmlElement(name = "VerbatimCollectingDate", nillable = true)
    protected java.util.List<String> verbatimCollectingDate;
    @XmlElement(name = "FieldNotes", nillable = true)
    protected java.util.List<String> fieldNotes;
    @XmlElement(name = "JulianDay", nillable = true)
    protected java.util.List<String> julianDay;
    @XmlElement(name = "HigherGeography", nillable = true)
    protected java.util.List<String> higherGeography;
    @XmlElement(name = "ContinentOcean", nillable = true)
    protected java.util.List<String> continentOcean;
    @XmlElement(name = "IslandGroup", nillable = true)
    protected java.util.List<String> islandGroup;
    @XmlElement(name = "Island", nillable = true)
    protected java.util.List<String> island;
    @XmlElement(name = "Country", nillable = true)
    protected java.util.List<String> country;
    @XmlElement(name = "StateProvince", nillable = true)
    protected java.util.List<String> stateProvince;
    @XmlElement(name = "County", nillable = true)
    protected java.util.List<String> county;
    @XmlElement(name = "Locality", nillable = true)
    protected java.util.List<String> locality;
    @XmlElement(name = "DecimalLatitude", nillable = true)
    protected java.util.List<BigDecimal> decimalLatitude;
    @XmlElement(name = "DecimalLongitude", nillable = true)
    protected java.util.List<BigDecimal> decimalLongitude;
    @XmlElement(name = "HorizontalDatum", nillable = true)
    protected java.util.List<String> horizontalDatum;
    @XmlElement(name = "OriginalCoordinateSystem", nillable = true)
    protected java.util.List<String> originalCoordinateSystem;
    @XmlElement(name = "VerbatimLatitude", nillable = true)
    protected java.util.List<String> verbatimLatitude;
    @XmlElement(name = "VerbatimLongitude", nillable = true)
    protected java.util.List<String> verbatimLongitude;
    @XmlElement(name = "GeorefMethod", nillable = true)
    protected java.util.List<String> georefMethod;
    @XmlElement(name = "CoordinateUncertaintyInMeters", nillable = true)
    protected java.util.List<BigDecimal> coordinateUncertaintyInMeters;
    @XmlElement(name = "LatLongComments", nillable = true)
    protected java.util.List<BigDecimal> latLongComments;
    @XmlElement(name = "BoundingBox", nillable = true)
    protected java.util.List<String> boundingBox;
    @XmlElement(name = "MinimumElevationInMeters", nillable = true)
    protected java.util.List<BigDecimal> minimumElevationInMeters;
    @XmlElement(name = "MaximumElevationInMeters", nillable = true)
    protected java.util.List<BigDecimal> maximumElevationInMeters;
    @XmlElement(name = "VerbatimElevation", nillable = true)
    protected java.util.List<String> verbatimElevation;
    @XmlElement(name = "MinimumDepthInMeters", nillable = true)
    protected java.util.List<BigDecimal> minimumDepthInMeters;
    @XmlElement(name = "MaximumDepthInMeters", nillable = true)
    protected java.util.List<BigDecimal> maximumDepthInMeters;
    @XmlElement(name = "VerbatimDepth", nillable = true)
    protected java.util.List<String> verbatimDepth;
    @XmlElement(name = "ScientificName", nillable = true)
    protected java.util.List<String> scientificName;
    @XmlElement(name = "HigherTaxon", nillable = true)
    protected java.util.List<String> higherTaxon;
    @XmlElement(name = "Kingdom", nillable = true)
    protected java.util.List<String> kingdom;
    @XmlElement(name = "Phylum", nillable = true)
    protected java.util.List<String> phylum;
    @XmlElement(name = "Class", nillable = true)
    protected java.util.List<String> clazz;
    @XmlElement(name = "Order", nillable = true)
    protected java.util.List<String> order;
    @XmlElement(name = "Family", nillable = true)
    protected java.util.List<String> family;
    @XmlElement(name = "Genus", nillable = true)
    protected java.util.List<String> genus;
    @XmlElement(name = "Species", nillable = true)
    protected java.util.List<String> species;
    @XmlElement(name = "Subspecies", nillable = true)
    protected java.util.List<String> subspecies;
    @XmlElement(name = "ScientificNameAuthor", nillable = true)
    protected java.util.List<String> scientificNameAuthor;
    @XmlElement(name = "IdentificationModifier", nillable = true)
    protected java.util.List<String> identificationModifier;
    @XmlElement(name = "IdentifiedBy", nillable = true)
    protected java.util.List<String> identifiedBy;
    @XmlElement(name = "YearIdentified", nillable = true)
    @XmlSchemaType(name = "gYear")
    protected java.util.List<XMLGregorianCalendar> yearIdentified;
    @XmlElement(name = "MonthIdentified", nillable = true)
    protected java.util.List<Integer> monthIdentified;
    @XmlElement(name = "DayIdentified", nillable = true)
    protected java.util.List<Integer> dayIdentified;
    @XmlElement(name = "TypeStatus", nillable = true)
    protected java.util.List<String> typeStatus;
    @XmlElement(name = "Sex", nillable = true)
    protected java.util.List<String> sex;
    @XmlElement(name = "Preparations", nillable = true)
    protected java.util.List<String> preparations;
    @XmlElement(name = "Tissues", nillable = true)
    protected java.util.List<String> tissues;
    @XmlElement(name = "IndividualCount", nillable = true)
    @XmlSchemaType(name = "nonNegativeInteger")
    protected java.util.List<BigInteger> individualCount;
    @XmlElement(name = "AgeClass", nillable = true)
    protected java.util.List<String> ageClass;
    @XmlElement(name = "GenBankNum", nillable = true)
    protected java.util.List<String> genBankNum;
    @XmlElement(name = "OtherCatalogNumbers", nillable = true)
    protected java.util.List<String> otherCatalogNumbers;
    @XmlElement(name = "RelatedCatalogedItems", nillable = true)
    protected java.util.List<String> relatedCatalogedItems;
    @XmlElement(name = "Remarks", nillable = true)
    protected java.util.List<String> remarks;

    /**
     * Gets the value of the dateLastModified property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dateLastModified property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDateLastModified().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLGregorianCalendar }
     * 
     * 
     */
    public java.util.List<XMLGregorianCalendar> getDateLastModified() {
        if (dateLastModified == null) {
            dateLastModified = new ArrayList<XMLGregorianCalendar>();
        }
        return this.dateLastModified;
    }

    /**
     * Gets the value of the basisOfRecord property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the basisOfRecord property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBasisOfRecord().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getBasisOfRecord() {
        if (basisOfRecord == null) {
            basisOfRecord = new ArrayList<String>();
        }
        return this.basisOfRecord;
    }

    /**
     * Gets the value of the institutionCode property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the institutionCode property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInstitutionCode().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getInstitutionCode() {
        if (institutionCode == null) {
            institutionCode = new ArrayList<String>();
        }
        return this.institutionCode;
    }

    /**
     * Gets the value of the collectionCode property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collectionCode property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollectionCode().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCollectionCode() {
        if (collectionCode == null) {
            collectionCode = new ArrayList<String>();
        }
        return this.collectionCode;
    }

    /**
     * Gets the value of the catalogNumberText property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the catalogNumberText property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCatalogNumberText().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCatalogNumberText() {
        if (catalogNumberText == null) {
            catalogNumberText = new ArrayList<String>();
        }
        return this.catalogNumberText;
    }

    /**
     * Gets the value of the catalogNumberNumeric property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the catalogNumberNumeric property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCatalogNumberNumeric().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigInteger }
     * 
     * 
     */
    public java.util.List<BigInteger> getCatalogNumberNumeric() {
        if (catalogNumberNumeric == null) {
            catalogNumberNumeric = new ArrayList<BigInteger>();
        }
        return this.catalogNumberNumeric;
    }

    /**
     * Gets the value of the collector property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collector property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollector().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCollector() {
        if (collector == null) {
            collector = new ArrayList<String>();
        }
        return this.collector;
    }

    /**
     * Gets the value of the collectorNumber property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collectorNumber property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollectorNumber().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCollectorNumber() {
        if (collectorNumber == null) {
            collectorNumber = new ArrayList<String>();
        }
        return this.collectorNumber;
    }

    /**
     * Gets the value of the fieldNumber property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fieldNumber property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFieldNumber().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getFieldNumber() {
        if (fieldNumber == null) {
            fieldNumber = new ArrayList<String>();
        }
        return this.fieldNumber;
    }

    /**
     * Gets the value of the yearCollected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the yearCollected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getYearCollected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLGregorianCalendar }
     * 
     * 
     */
    public java.util.List<XMLGregorianCalendar> getYearCollected() {
        if (yearCollected == null) {
            yearCollected = new ArrayList<XMLGregorianCalendar>();
        }
        return this.yearCollected;
    }

    /**
     * Gets the value of the monthCollected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the monthCollected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMonthCollected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Integer }
     * 
     * 
     */
    public java.util.List<Integer> getMonthCollected() {
        if (monthCollected == null) {
            monthCollected = new ArrayList<Integer>();
        }
        return this.monthCollected;
    }

    /**
     * Gets the value of the dayCollected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dayCollected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDayCollected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Integer }
     * 
     * 
     */
    public java.util.List<Integer> getDayCollected() {
        if (dayCollected == null) {
            dayCollected = new ArrayList<Integer>();
        }
        return this.dayCollected;
    }

    /**
     * Gets the value of the timeCollected property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the timeCollected property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTimeCollected().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getTimeCollected() {
        if (timeCollected == null) {
            timeCollected = new ArrayList<BigDecimal>();
        }
        return this.timeCollected;
    }

    /**
     * Gets the value of the verbatimCollectingDate property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the verbatimCollectingDate property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVerbatimCollectingDate().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getVerbatimCollectingDate() {
        if (verbatimCollectingDate == null) {
            verbatimCollectingDate = new ArrayList<String>();
        }
        return this.verbatimCollectingDate;
    }

    /**
     * Gets the value of the fieldNotes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fieldNotes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFieldNotes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getFieldNotes() {
        if (fieldNotes == null) {
            fieldNotes = new ArrayList<String>();
        }
        return this.fieldNotes;
    }

    /**
     * Gets the value of the julianDay property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the julianDay property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getJulianDay().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getJulianDay() {
        if (julianDay == null) {
            julianDay = new ArrayList<String>();
        }
        return this.julianDay;
    }

    /**
     * Gets the value of the higherGeography property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the higherGeography property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHigherGeography().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getHigherGeography() {
        if (higherGeography == null) {
            higherGeography = new ArrayList<String>();
        }
        return this.higherGeography;
    }

    /**
     * Gets the value of the continentOcean property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the continentOcean property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getContinentOcean().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getContinentOcean() {
        if (continentOcean == null) {
            continentOcean = new ArrayList<String>();
        }
        return this.continentOcean;
    }

    /**
     * Gets the value of the islandGroup property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the islandGroup property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIslandGroup().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getIslandGroup() {
        if (islandGroup == null) {
            islandGroup = new ArrayList<String>();
        }
        return this.islandGroup;
    }

    /**
     * Gets the value of the island property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the island property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsland().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getIsland() {
        if (island == null) {
            island = new ArrayList<String>();
        }
        return this.island;
    }

    /**
     * Gets the value of the country property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the country property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCountry().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCountry() {
        if (country == null) {
            country = new ArrayList<String>();
        }
        return this.country;
    }

    /**
     * Gets the value of the stateProvince property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the stateProvince property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStateProvince().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getStateProvince() {
        if (stateProvince == null) {
            stateProvince = new ArrayList<String>();
        }
        return this.stateProvince;
    }

    /**
     * Gets the value of the county property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the county property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCounty().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getCounty() {
        if (county == null) {
            county = new ArrayList<String>();
        }
        return this.county;
    }

    /**
     * Gets the value of the locality property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the locality property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLocality().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getLocality() {
        if (locality == null) {
            locality = new ArrayList<String>();
        }
        return this.locality;
    }

    /**
     * Gets the value of the decimalLatitude property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the decimalLatitude property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDecimalLatitude().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getDecimalLatitude() {
        if (decimalLatitude == null) {
            decimalLatitude = new ArrayList<BigDecimal>();
        }
        return this.decimalLatitude;
    }

    /**
     * Gets the value of the decimalLongitude property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the decimalLongitude property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDecimalLongitude().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getDecimalLongitude() {
        if (decimalLongitude == null) {
            decimalLongitude = new ArrayList<BigDecimal>();
        }
        return this.decimalLongitude;
    }

    /**
     * Gets the value of the horizontalDatum property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the horizontalDatum property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHorizontalDatum().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getHorizontalDatum() {
        if (horizontalDatum == null) {
            horizontalDatum = new ArrayList<String>();
        }
        return this.horizontalDatum;
    }

    /**
     * Gets the value of the originalCoordinateSystem property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the originalCoordinateSystem property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOriginalCoordinateSystem().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getOriginalCoordinateSystem() {
        if (originalCoordinateSystem == null) {
            originalCoordinateSystem = new ArrayList<String>();
        }
        return this.originalCoordinateSystem;
    }

    /**
     * Gets the value of the verbatimLatitude property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the verbatimLatitude property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVerbatimLatitude().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getVerbatimLatitude() {
        if (verbatimLatitude == null) {
            verbatimLatitude = new ArrayList<String>();
        }
        return this.verbatimLatitude;
    }

    /**
     * Gets the value of the verbatimLongitude property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the verbatimLongitude property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVerbatimLongitude().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getVerbatimLongitude() {
        if (verbatimLongitude == null) {
            verbatimLongitude = new ArrayList<String>();
        }
        return this.verbatimLongitude;
    }

    /**
     * Gets the value of the georefMethod property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the georefMethod property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeorefMethod().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getGeorefMethod() {
        if (georefMethod == null) {
            georefMethod = new ArrayList<String>();
        }
        return this.georefMethod;
    }

    /**
     * Gets the value of the coordinateUncertaintyInMeters property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the coordinateUncertaintyInMeters property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCoordinateUncertaintyInMeters().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getCoordinateUncertaintyInMeters() {
        if (coordinateUncertaintyInMeters == null) {
            coordinateUncertaintyInMeters = new ArrayList<BigDecimal>();
        }
        return this.coordinateUncertaintyInMeters;
    }

    /**
     * Gets the value of the latLongComments property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the latLongComments property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLatLongComments().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getLatLongComments() {
        if (latLongComments == null) {
            latLongComments = new ArrayList<BigDecimal>();
        }
        return this.latLongComments;
    }

    /**
     * Gets the value of the boundingBox property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the boundingBox property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBoundingBox().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getBoundingBox() {
        if (boundingBox == null) {
            boundingBox = new ArrayList<String>();
        }
        return this.boundingBox;
    }

    /**
     * Gets the value of the minimumElevationInMeters property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the minimumElevationInMeters property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMinimumElevationInMeters().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getMinimumElevationInMeters() {
        if (minimumElevationInMeters == null) {
            minimumElevationInMeters = new ArrayList<BigDecimal>();
        }
        return this.minimumElevationInMeters;
    }

    /**
     * Gets the value of the maximumElevationInMeters property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the maximumElevationInMeters property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMaximumElevationInMeters().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getMaximumElevationInMeters() {
        if (maximumElevationInMeters == null) {
            maximumElevationInMeters = new ArrayList<BigDecimal>();
        }
        return this.maximumElevationInMeters;
    }

    /**
     * Gets the value of the verbatimElevation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the verbatimElevation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVerbatimElevation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getVerbatimElevation() {
        if (verbatimElevation == null) {
            verbatimElevation = new ArrayList<String>();
        }
        return this.verbatimElevation;
    }

    /**
     * Gets the value of the minimumDepthInMeters property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the minimumDepthInMeters property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMinimumDepthInMeters().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getMinimumDepthInMeters() {
        if (minimumDepthInMeters == null) {
            minimumDepthInMeters = new ArrayList<BigDecimal>();
        }
        return this.minimumDepthInMeters;
    }

    /**
     * Gets the value of the maximumDepthInMeters property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the maximumDepthInMeters property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMaximumDepthInMeters().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigDecimal }
     * 
     * 
     */
    public java.util.List<BigDecimal> getMaximumDepthInMeters() {
        if (maximumDepthInMeters == null) {
            maximumDepthInMeters = new ArrayList<BigDecimal>();
        }
        return this.maximumDepthInMeters;
    }

    /**
     * Gets the value of the verbatimDepth property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the verbatimDepth property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVerbatimDepth().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getVerbatimDepth() {
        if (verbatimDepth == null) {
            verbatimDepth = new ArrayList<String>();
        }
        return this.verbatimDepth;
    }

    /**
     * Gets the value of the scientificName property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the scientificName property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getScientificName().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getScientificName() {
        if (scientificName == null) {
            scientificName = new ArrayList<String>();
        }
        return this.scientificName;
    }

    /**
     * Gets the value of the higherTaxon property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the higherTaxon property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHigherTaxon().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getHigherTaxon() {
        if (higherTaxon == null) {
            higherTaxon = new ArrayList<String>();
        }
        return this.higherTaxon;
    }

    /**
     * Gets the value of the kingdom property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the kingdom property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKingdom().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getKingdom() {
        if (kingdom == null) {
            kingdom = new ArrayList<String>();
        }
        return this.kingdom;
    }

    /**
     * Gets the value of the phylum property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the phylum property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhylum().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getPhylum() {
        if (phylum == null) {
            phylum = new ArrayList<String>();
        }
        return this.phylum;
    }

    /**
     * Gets the value of the clazz property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the clazz property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getClazz().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getClazz() {
        if (clazz == null) {
            clazz = new ArrayList<String>();
        }
        return this.clazz;
    }

    /**
     * Gets the value of the order property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the order property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOrder().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getOrder() {
        if (order == null) {
            order = new ArrayList<String>();
        }
        return this.order;
    }

    /**
     * Gets the value of the family property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the family property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFamily().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getFamily() {
        if (family == null) {
            family = new ArrayList<String>();
        }
        return this.family;
    }

    /**
     * Gets the value of the genus property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the genus property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGenus().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getGenus() {
        if (genus == null) {
            genus = new ArrayList<String>();
        }
        return this.genus;
    }

    /**
     * Gets the value of the species property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the species property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSpecies().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getSpecies() {
        if (species == null) {
            species = new ArrayList<String>();
        }
        return this.species;
    }

    /**
     * Gets the value of the subspecies property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subspecies property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubspecies().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getSubspecies() {
        if (subspecies == null) {
            subspecies = new ArrayList<String>();
        }
        return this.subspecies;
    }

    /**
     * Gets the value of the scientificNameAuthor property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the scientificNameAuthor property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getScientificNameAuthor().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getScientificNameAuthor() {
        if (scientificNameAuthor == null) {
            scientificNameAuthor = new ArrayList<String>();
        }
        return this.scientificNameAuthor;
    }

    /**
     * Gets the value of the identificationModifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identificationModifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentificationModifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getIdentificationModifier() {
        if (identificationModifier == null) {
            identificationModifier = new ArrayList<String>();
        }
        return this.identificationModifier;
    }

    /**
     * Gets the value of the identifiedBy property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the identifiedBy property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIdentifiedBy().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getIdentifiedBy() {
        if (identifiedBy == null) {
            identifiedBy = new ArrayList<String>();
        }
        return this.identifiedBy;
    }

    /**
     * Gets the value of the yearIdentified property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the yearIdentified property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getYearIdentified().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLGregorianCalendar }
     * 
     * 
     */
    public java.util.List<XMLGregorianCalendar> getYearIdentified() {
        if (yearIdentified == null) {
            yearIdentified = new ArrayList<XMLGregorianCalendar>();
        }
        return this.yearIdentified;
    }

    /**
     * Gets the value of the monthIdentified property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the monthIdentified property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMonthIdentified().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Integer }
     * 
     * 
     */
    public java.util.List<Integer> getMonthIdentified() {
        if (monthIdentified == null) {
            monthIdentified = new ArrayList<Integer>();
        }
        return this.monthIdentified;
    }

    /**
     * Gets the value of the dayIdentified property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dayIdentified property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDayIdentified().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Integer }
     * 
     * 
     */
    public java.util.List<Integer> getDayIdentified() {
        if (dayIdentified == null) {
            dayIdentified = new ArrayList<Integer>();
        }
        return this.dayIdentified;
    }

    /**
     * Gets the value of the typeStatus property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the typeStatus property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTypeStatus().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getTypeStatus() {
        if (typeStatus == null) {
            typeStatus = new ArrayList<String>();
        }
        return this.typeStatus;
    }

    /**
     * Gets the value of the sex property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sex property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSex().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getSex() {
        if (sex == null) {
            sex = new ArrayList<String>();
        }
        return this.sex;
    }

    /**
     * Gets the value of the preparations property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the preparations property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPreparations().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getPreparations() {
        if (preparations == null) {
            preparations = new ArrayList<String>();
        }
        return this.preparations;
    }

    /**
     * Gets the value of the tissues property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the tissues property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTissues().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getTissues() {
        if (tissues == null) {
            tissues = new ArrayList<String>();
        }
        return this.tissues;
    }

    /**
     * Gets the value of the individualCount property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the individualCount property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIndividualCount().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BigInteger }
     * 
     * 
     */
    public java.util.List<BigInteger> getIndividualCount() {
        if (individualCount == null) {
            individualCount = new ArrayList<BigInteger>();
        }
        return this.individualCount;
    }

    /**
     * Gets the value of the ageClass property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ageClass property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAgeClass().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getAgeClass() {
        if (ageClass == null) {
            ageClass = new ArrayList<String>();
        }
        return this.ageClass;
    }

    /**
     * Gets the value of the genBankNum property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the genBankNum property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGenBankNum().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getGenBankNum() {
        if (genBankNum == null) {
            genBankNum = new ArrayList<String>();
        }
        return this.genBankNum;
    }

    /**
     * Gets the value of the otherCatalogNumbers property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherCatalogNumbers property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherCatalogNumbers().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getOtherCatalogNumbers() {
        if (otherCatalogNumbers == null) {
            otherCatalogNumbers = new ArrayList<String>();
        }
        return this.otherCatalogNumbers;
    }

    /**
     * Gets the value of the relatedCatalogedItems property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the relatedCatalogedItems property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRelatedCatalogedItems().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getRelatedCatalogedItems() {
        if (relatedCatalogedItems == null) {
            relatedCatalogedItems = new ArrayList<String>();
        }
        return this.relatedCatalogedItems;
    }

    /**
     * Gets the value of the remarks property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the remarks property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRemarks().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public java.util.List<String> getRemarks() {
        if (remarks == null) {
            remarks = new ArrayList<String>();
        }
        return this.remarks;
    }

}
